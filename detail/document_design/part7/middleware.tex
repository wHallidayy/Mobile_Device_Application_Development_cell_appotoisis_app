\section{Middleware / Guard Implementation}

Middleware ในระบบนี้ถูกออกแบบตามมาตรฐานความปลอดภัย \textbf{OWASP Application Security Verification Standard (ASVS)} โดยมีการจัดการ HTTP Status Codes และ Header ตามมาตรฐาน \textbf{IETF RFC 9110} (HTTP Semantics) และ \textbf{RFC 6750} (Bearer Token Usage)

% ============================================================================
\subsection{Security Standards Reference}

\begin{table}[h]
\centering
\caption{มาตรฐานอ้างอิงสำหรับ Middleware}
\begin{tabular}{|p{3cm}|p{4cm}|p{6.5cm}|}
\hline
\textbf{มาตรฐาน} & \textbf{หมวด} & \textbf{การนำไปใช้} \\
\hline
OWASP ASVS V2 & Authentication & กำหนดว่าทำไมต้องตรวจสอบ Token ทุก Request และกำหนด Session Timeout \\
\hline
OWASP ASVS V4 & Access Control & กำหนดว่าทำไมต้องเช็ค Role ทุก Request (Principle of Least Privilege) \\
\hline
OWASP Secure Headers & Security Headers & กำหนด Headers ที่ควรมีเพื่อป้องกัน Common Attacks \\
\hline
IETF RFC 9110 & HTTP Semantics & กำหนด HTTP Status Codes ที่เหมาะสม (401 vs 403) \\
\hline
IETF RFC 6750 & Bearer Token & กำหนด Format ของ Authorization Header \\
\hline
\end{tabular}
\end{table}

\clearpage

% ============================================================================
\subsection{Authentication Middleware}

\subsubsection{หลักการออกแบบ (OWASP ASVS V2)}

ตาม \textbf{OWASP ASVS V2.1} (Authentication Verification Requirements):
\begin{itemize}
    \item \textbf{V2.1.1}: ทุก Request ที่เข้าถึง Protected Resource ต้องถูกตรวจสอบ Authentication
    \item \textbf{V2.1.5}: Token ต้องมี Expiration Time และต้องถูกตรวจสอบทุกครั้ง
    \item \textbf{V2.3.1}: ใช้ Cryptographically Strong Token (PASETO V4 Local)
\end{itemize}

\subsubsection{Token Extraction (RFC 6750)}

การ Extract Token จาก HTTP Request ตามมาตรฐาน \textbf{RFC 6750 Section 2.1} (Authorization Request Header Field):

\begin{lstlisting}[language=Rust, caption=Bearer Token Extraction ตาม RFC 6750]
// RFC 6750 Section 2.1: Authorization: Bearer <token>
fn extract_bearer_token(req: &ServiceRequest) -> Option<String> {
    let auth_header = req.headers()
        .get(actix_web::http::header::AUTHORIZATION)?
        .to_str().ok()?;
    
    // Format: "Bearer <token>"
    if auth_header.starts_with("Bearer ") {
        Some(auth_header[7..].to_string())
    } else {
        None
    }
}
\end{lstlisting}

\clearpage

\subsubsection{PASETO Token Validation}

การ Validate PASETO V4 Local Token และ Extract Claims:

\begin{lstlisting}[language=Rust, caption=PASETO Token Validation]
fn validate_token(token: &str, jwt_config: &JwtConfig) -> Result<TokenClaims, AuthMiddlewareError> {
    // Create symmetric key from config (using secrecy crate)
    let secret = jwt_config.secret.expose_secret();
    let key_bytes: [u8; 32] = {
        let bytes = secret.as_bytes();
        let mut arr = [0u8; 32];
        let len = std::cmp::min(bytes.len(), 32);
        arr[..len].copy_from_slice(&bytes[..len]);
        arr
    };

    let secret_key = Key::<32>::from(key_bytes);
    let key = PasetoSymmetricKey::<V4, Local>::from(secret_key);

    // Parse and decrypt PASETO token
    let value = PasetoParser::<V4, Local>::default()
        .parse(token, &key)
        .map_err(|_| AuthMiddlewareError::InvalidToken)?;

    // Extract claims
    let claims: TokenClaims = serde_json::from_value(value)
        .map_err(|_| AuthMiddlewareError::InvalidToken)?;

    // Validate token type (must be "access")
    if claims.token_type != "access" {
        return Err(AuthMiddlewareError::InvalidTokenType);
    }

    // Validate expiration (OWASP ASVS V2.1.5)
    let expiration = chrono::DateTime::parse_from_rfc3339(&claims.exp)
        .map_err(|_| AuthMiddlewareError::InvalidToken)?;
    
    if expiration < chrono::Utc::now() {
        return Err(AuthMiddlewareError::TokenExpired);
    }

    Ok(claims)
}
\end{lstlisting}

\subsubsection{AuthenticatedUser Injection}

หลังจาก Validate Token สำเร็จ จะ Inject User Information เข้าไปใน Request Extensions:

\begin{lstlisting}[language=Rust, caption=Authenticated User Data Structure]
#[derive(Debug, Clone)]
pub struct AuthenticatedUser {
    pub user_id: Uuid,
    pub username: String,
    pub role: UserRole,
}

// Inject into request extensions
req.extensions_mut().insert(AuthenticatedUser {
    user_id: claims.sub,
    username: claims.username,
    role: claims.role,
});
\end{lstlisting}

% ============================================================================
\subsection{Authorization Middleware (Role Guard)}

\subsubsection{หลักการออกแบบ (OWASP ASVS V4)}

ตาม \textbf{OWASP ASVS V4} (Access Control Verification Requirements):
\begin{itemize}
    \item \textbf{V4.1.1}: ทุก Request ต้องถูกตรวจสอบ Authorization ที่ Server-side
    \item \textbf{V4.1.2}: ใช้หลัก Principle of Least Privilege - ให้สิทธิ์น้อยที่สุดที่จำเป็น
    \item \textbf{V4.1.3}: Deny by Default - ปฏิเสธทุกอย่างก่อน แล้วค่อย Allow เฉพาะที่อนุญาต
\end{itemize}

\subsubsection{Role-Based Access Control (RBAC)}

\begin{lstlisting}[language=Rust, caption=Role Guard Implementation]
pub struct RoleGuard {
    pub allowed_roles: Vec<UserRole>,
}

impl RoleGuard {
    pub fn new(roles: Vec<UserRole>) -> Self {
        Self { allowed_roles: roles }
    }
    
    pub fn check(&self, user: &AuthenticatedUser) -> bool {
        // OWASP ASVS V4.1.2: Principle of Least Privilege
        self.allowed_roles.contains(&user.role)
    }
}

// Usage example: Only Researcher and Lecturer can access
let guard = RoleGuard::new(vec![UserRole::Researcher, UserRole::Lecturer]);
\end{lstlisting}

% ============================================================================
\subsection{HTTP Status Code Compliance (RFC 9110)}

\subsubsection{401 Unauthorized vs 403 Forbidden}

ตาม \textbf{RFC 9110 Section 15.5.2} และ \textbf{15.5.4}:

\begin{table}[h]
\centering
\caption{HTTP Status Codes สำหรับ Authentication/Authorization Errors}
\begin{tabular}{|p{2.5cm}|p{3.5cm}|p{7.5cm}|}
\hline
\textbf{Status Code} & \textbf{ชื่อ} & \textbf{เงื่อนไขการใช้งาน} \\
\hline
\texttt{401} & Unauthorized & ไม่มี Token หรือ Token ไม่ถูกต้อง/หมดอายุ (Authentication Failed) \\
\hline
\texttt{403} & Forbidden & มี Token ถูกต้อง แต่ไม่มีสิทธิ์เข้าถึง Resource นั้น (Authorization Failed) \\
\hline
\end{tabular}
\end{table}

\clearpage

\begin{lstlisting}[language=Rust, caption=HTTP Status Code Mapping]
match error {
    AuthMiddlewareError::MissingToken => {
        // RFC 9110 Section 15.5.2: 401 Unauthorized
        HttpResponse::Unauthorized()
            .insert_header(("WWW-Authenticate", "Bearer"))
            .json(/* error response */)
    }
    AuthMiddlewareError::InvalidToken |
    AuthMiddlewareError::TokenExpired => {
        // RFC 9110 Section 15.5.2: 401 Unauthorized
        HttpResponse::Unauthorized()
            .insert_header(("WWW-Authenticate", 
                "Bearer error=\"invalid_token\""))
            .json(/* error response */)
    }
    AuthMiddlewareError::InsufficientPermissions => {
        // RFC 9110 Section 15.5.4: 403 Forbidden
        HttpResponse::Forbidden()
            .json(/* error response */)
    }
}
\end{lstlisting}

\clearpage

\paragraph{WWW-Authenticate Header (RFC 6750 Section 3)}~\\
เมื่อคืน 401 Unauthorized ต้องแนบ \texttt{WWW-Authenticate} header ตาม RFC 6750:
\begin{itemize}
    \item \texttt{Bearer} - เมื่อไม่มี Token
    \item \texttt{Bearer error="invalid\_token"} - เมื่อ Token ไม่ถูกต้องหรือหมดอายุ
\end{itemize}

% ============================================================================
\subsection{Security Headers Middleware}

\subsubsection{หลักการออกแบบ (OWASP Secure Headers)}

ตาม \textbf{OWASP Secure Headers Project} แนะนำ Headers ที่ควรมีเพื่อป้องกัน Common Web Attacks:

\begin{table}[h]
\centering
\begin{tabular}{|p{5cm}|p{4cm}|p{5cm}|}
\hline
\textbf{Header} & \textbf{Value} & \textbf{ป้องกัน/วัตถุประสงค์} \\
\hline
\texttt{Strict-Transport-Security} & \texttt{max-age=31536000; includeSubDomains} & Man-in-the-Middle Attack (บังคับใช้ HTTPS 1 ปี) \\
\hline
\texttt{X-Content-Type-Options} & \texttt{nosniff} & MIME Type Sniffing Attack \\
\hline
\texttt{X-Frame-Options} & \texttt{DENY} & Clickjacking (Disable iframe) \\
\hline
\texttt{X-XSS-Protection} & \texttt{0} & Disable Legacy XSS Filter (OWASP verify) \\
\hline
\texttt{Referrer-Policy} & \texttt{strict-origin-when-cross-origin} & ควบคุมข้อมูล Referrer เมื่อข้าม Origin \\
\hline
\texttt{Permissions-Policy} & \texttt{geolocation=(), microphone=(), camera=()} & ปิดการเข้าถึง Hardware features โดยไม่จำเป็น \\
\hline
\end{tabular}
\end{table}

\begin{lstlisting}[language=Rust, caption=Security Headers Middleware Implementation]
pub struct SecurityHeadersService<S> {
    service: Rc<S>,
}

impl<S, B> Service<ServiceRequest> for SecurityHeadersService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + 'static,
{
    // ... impl details ...

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let service = self.service.clone();

        Box::pin(async move {
            let mut res = service.call(req).await?;
            let headers = res.headers_mut();

            // Strict-Transport-Security (HSTS)
            headers.insert(
                HeaderName::from_static("strict-transport-security"),
                HeaderValue::from_static("max-age=31536000; includeSubDomains"),
            );

            // X-Content-Type-Options
            headers.insert(
                HeaderName::from_static("x-content-type-options"),
                HeaderValue::from_static("nosniff"),
            );

            // X-Frame-Options
            headers.insert(
                HeaderName::from_static("x-frame-options"),
                HeaderValue::from_static("DENY"),
            );

            // X-XSS-Protection
            headers.insert(
                HeaderName::from_static("x-xss-protection"),
                HeaderValue::from_static("0"),
            );

            // Referrer-Policy
            headers.insert(
                HeaderName::from_static("referrer-policy"),
                HeaderValue::from_static("strict-origin-when-cross-origin"),
            );

            // Permissions-Policy
            headers.insert(
                HeaderName::from_static("permissions-policy"),
                HeaderValue::from_static("geolocation=(), microphone=(), camera=()"),
            );

            Ok(res)
        })
    }
}
\end{lstlisting}

\clearpage

% ============================================================================
\subsection{Middleware Architecture}

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance=1.8cm, auto]
    % Styles
    \tikzstyle{layer} = [rectangle, draw, fill=blue!15, text width=4.5cm, text centered, minimum height=1cm, rounded corners]
    \tikzstyle{decision} = [diamond, draw, fill=yellow!20, text width=2cm, text centered, aspect=2]
    \tikzstyle{arrow} = [thick, ->, >=stealth]
    \tikzstyle{error} = [rectangle, draw, fill=red!15, text width=2.5cm, text centered, minimum height=0.8cm, rounded corners]
    
    % Nodes
    \node[layer] (request) {HTTP Request};
    \node[layer, below of=request] (security) {Security Headers MW};
    \node[layer, below of=security] (auth) {Authentication MW};
    \node[decision, below of=auth, node distance=2cm] (valid) {Token Valid?};
    \node[layer, below of=valid, node distance=2cm] (role) {Role Guard MW};
    \node[decision, below of=role, node distance=2cm] (perm) {Has Permission?};
    \node[layer, below of=perm, node distance=2cm] (handler) {Handler};
    
    \node[error, right of=valid, node distance=4cm] (e401) {401 Unauthorized};
    \node[error, right of=perm, node distance=4cm] (e403) {403 Forbidden};
    
    % Arrows
    \draw[arrow] (request) -- (security);
    \draw[arrow] (security) -- (auth);
    \draw[arrow] (auth) -- (valid);
    \draw[arrow] (valid) -- node[left] {Yes} (role);
    \draw[arrow] (valid) -- node[above] {No} (e401);
    \draw[arrow] (role) -- (perm);
    \draw[arrow] (perm) -- node[left] {Yes} (handler);
    \draw[arrow] (perm) -- node[above] {No} (e403);
\end{tikzpicture}
\caption{Middleware Pipeline Architecture}
\end{figure}

\clearpage

% ============================================================================
\subsection{Complexity Analysis}

\begin{table}[h]
\centering
\caption{Time Complexity ของ Middleware Operations}
\begin{tabular}{|p{4cm}|p{2.5cm}|p{7cm}|}
\hline
\textbf{Operation} & \textbf{Time Complexity} & \textbf{Explanation} \\
\hline
Token Extraction & $O(1)$ & Header lookup เป็น hash map operation \\
\hline
PASETO Decryption & $O(n)$ & โดยที่ $n$ = token length; XChaCha20 decryption \\
\hline
Claims Validation & $O(1)$ & เช็ค expiration time เป็น simple comparison \\
\hline
Role Check & $O(r)$ & โดยที่ $r$ = จำนวน allowed roles; linear search \\
\hline
Security Headers & $O(h)$ & โดยที่ $h$ = จำนวน headers ที่เพิ่ม (constant ~6) \\
\hline
\end{tabular}
\end{table}

\paragraph{Overall Middleware Pipeline Complexity}~\\
$O(n + r)$ โดยที่ $n$ = token length, $r$ = allowed roles

สำหรับ typical use case ($n \approx 200$ bytes, $r \leq 3$) ถือว่า negligible overhead ($< 1$ ms)

% ============================================================================
\subsection{Error Response Format}

ทุก Error Response ใช้ Format เดียวกับ API Response Wrapper:

\begin{lstlisting}[language=Rust, caption=Middleware Error Response]
#[derive(Debug, Serialize)]
struct ErrorResponse {
    success: bool,        // always false
    error: ErrorDetail,
}

#[derive(Debug, Serialize)]
struct ErrorDetail {
    code: String,         // e.g., "UNAUTHORIZED", "FORBIDDEN"
    message: String,      // Human-readable message
}

// Example: 401 Unauthorized response
{
    "success": false,
    "error": {
        "code": "MISSING_TOKEN",
        "message": "Missing authentication token"
    }
}
\end{lstlisting}

\subsubsection{Error Codes Reference}

ตารางแสดง Error Codes ที่คืนกลับจาก Middleware:

\begin{table}[h]
\centering
\caption{Middleware Error Codes}
\begin{tabular}{|p{4cm}|p{2cm}|p{7cm}|}
\hline
\textbf{Error Code} & \textbf{Status} & \textbf{Description} \\
\hline
\texttt{MISSING\_TOKEN} & 401 & ไม่พบ Authorization header หรือ Token ว่างเปล่า \\
\hline
\texttt{INVALID\_TOKEN\_FORMAT} & 401 & Token ผิดรูปแบบ (ต้องขึ้นต้นด้วย Bearer) \\
\hline
\texttt{INVALID\_TOKEN} & 401 & Token ไม่ถูกต้อง หรือ Decrypt ไม่ได้ \\
\hline
\texttt{TOKEN\_EXPIRED} & 401 & Token หมดอายุแล้ว \\
\hline
\texttt{INVALID\_TOKEN\_TYPE} & 401 & ประเภท Token ไม่ถูกต้อง (ต้องการ Access Token) \\
\hline
\texttt{INSUFFICIENT\_PERMISSIONS} & 403 & User role ไม่มีสิทธิ์เข้าถึง Resource นี้ \\
\hline
\texttt{CONFIG\_ERROR} & 500 & เกิดข้อผิดพลาดที่ Server configuration \\
\hline
\end{tabular}
\end{table}

\clearpage

% ============================================================================
\subsection{Protected Routes Configuration}

\begin{lstlisting}[language=Rust, caption=Route Protection Configuration]
// Public routes (no authentication required)
cfg.service(
    web::scope("/api/v1")
        .route("/health", web::get().to(health_check))
        .service(
            web::scope("/auth")
                .route("/register", web::post().to(register))
                .route("/login", web::post().to(login))
        )
);

// Protected routes (authentication required)
cfg.service(
    web::scope("/api/v1")
        .wrap(AuthenticationMiddleware::new(jwt_config))
        .service(
            web::scope("/images")
                .route("", web::post().to(upload_image))
                .route("/{id}", web::get().to(get_image))
        )
        .service(
            web::scope("/analysis")
                .route("", web::post().to(create_analysis))
        )
);
\end{lstlisting}
